继承是面向对象三大特性之一，另外两个是封装和多态

优点：减少重复的代码 

# 继承的基本语法

`class 子类 : 继承方式 父类 {}`

子类也称为派生类，父类也成为基类

# 继承方式

继承方式有三种

1. 公共继承
2. 保护继承
3. 私有继承

![image-20210102195646704](pics/11_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/image-20210102195646704.png)

# 继承中的对象模型

问题：从父类继承过来的成员，哪些属于子类对象中？

父类中所有的非静态成员属性都会被子类继承

父类中私有成员属性，被编译器隐藏，但是确实被继承

# 继承中的构造和析构顺序

先构造父类，再构造子类

先析构子类，再析构父类

# 继承中同名成员处理方式

* 访问子类同名成员属性或函数，直接访问即可
* 访问父类成员属性或函数，需要加作用域::



如果子类中出现和父类同名的成员函数，子类的成员函数会隐藏掉所有父类的同名成员函数，包括父类中重载的函数。如果想访问父类中的同名成员函数，需要加作用域

# 继承中同名静态成员处理

静态成员和非静态成员出现同名，处理方式一致

* 访问子类同名成员，直接访问即可
* 访问父类同名成员，需要加作用域::

如果子类中出现和父类同名的成员函数，子类的成员函数会隐藏掉所有父类的同名成员函数，包括父类中重载的函数。如果想访问父类中的同名成员函数，需要加作用域

# 多继承语法

C++允许一个类继承多个类

语法：`class 子类 : 继承方式 父类1, 继承方式 父类2, ... {}`

多继承可能会引发父类中有同名成员出现，需要加作用域区别

C++实际开发中不建议使用多继承

# 菱形继承问题及解决方法

菱形继承：

* 两个派生类继承同一个基类
* 又有某个类同时继承这两个类
* 这种继承成为菱形继承，也叫钻石继承



利用虚继承，解决菱形继承问题。在继承前加virtual，此时的基类称为虚基类。此时继承的不是数据，而是指针，指针通过偏移量找到唯一的数据



vbptr: 虚基类指针 virtual base pointer，指向vbtable（虚基类表）

![image-20210102231801466](pics/11_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/image-20210102231801466.png)