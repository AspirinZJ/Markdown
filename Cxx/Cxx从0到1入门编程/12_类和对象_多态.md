# 多态的基本概念

多态是C++面向对象三大特性之一

多态分为两类：

* 静态多态：函数重载和运算符重载，服用函数名
* 动态多态：派生类和虚函数实现运行时多态



静态多态和动态多态区别：

* 静态多态的函数地址早绑定-编译阶段确定函数地址
* 动态多态的函数地址晚绑定-运行阶段确定函数地址



动态多态的满足条件：

1. 有继承关系
2. 子类要重写父类的虚函数(重写：返回类型相同，函数名相同，形参列表相同)



动态多态使用：

* 父类的指针或者引用，指向子类对象

# 多态的原理剖析

vfptr： 虚函数指针，指向vftable

vftable：虚函数表，表内部记录虚函数的地址

![image-20210103000526515](pics/12_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1_%E5%A4%9A%E6%80%81/image-20210103000526515.png)

如上图，如果子类不重写父类虚函数，则继承和父类相同的虚函数表

![image-20210103000633741](pics/12_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1_%E5%A4%9A%E6%80%81/image-20210103000633741.png)

如上图，如果子类重写父类虚函数，子类中的虚函数表会替换成子类的虚函数地址



当父类的指针或引用指向子类对象时，就发生了多态

```c++
Cat cat;
Animal &animal = cat;
animal.speak(); // 由于指向Cat对象，所以会从Cat虚函数表中找函数，运行阶段发生动态多态
```

# 多态的优点

1. 代码组织结构清晰
2. 可读性强
3. 利于前期和后期的扩展以及维护

C++提倡使用多态设计程序架构

# 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是无意义的，主要都是调用子类重写的虚函数

因此可以将虚函数改为纯虚函数

纯虚函数语法：`virtual 返回值类型 函数名(参数列表) = 0;`

当类中有了纯虚函数，这个类也称为抽象类



抽象类特点：

* 无法实例化对象
* 子类必须重写抽象类中的纯虚函数，否则子类也属于抽象类

# 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为虚析构或纯虚析构



虚析构和纯虚析构共性：

* 可以解决父类指针释放子类对象
* 都需要有具体的函数实现

虚析构和纯虚析构区别：

* 如果是纯虚析构，该类属于抽象类，无法实例化对象



虚析构语法:`virtual ~类名(){}`

纯虚析构语法:

```c++
virutal ~类名() = 0;
// 类外
类名::~类名(){实现}
```

 



纯虚析构需要具体的实现.

