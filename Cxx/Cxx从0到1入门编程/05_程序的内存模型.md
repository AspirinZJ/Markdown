# 1 内存分区模型

> ==代码区==：存放函数体的二进制代码， 由操作系统管理
>
> ==全局区==：存放全局变量，静态变量和常量
>
> ==栈区==： 由编译器自动分配释放，存放函数的参数值，局部变量等
>
> ==堆区==： 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收



**内存四区意义：**

不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

## 1.1 程序执行前

在程序编译后，生成了可执行程序，未执行程序前分为两个区域

1. 代码区：
   1. 存放CPU执行的机器指令
   2. 代码去是共享的，共享的目录是对于频繁被执行的程序，只需要在内存中有一份代码即可
   3. 代码去是只读的，使其只读的原因是防止程序意外地修改了它的指令
2. 全局区
   1. ==全局变量==和静态变量存放于此
   2. 全局区还包含了==常量区==，字符串常量和==其他常量==存放于此
   3. 该区域的数据在程序结束后由操作系统释放

## 1.2 程序运行后

**栈区**：

​	由编译器自动分配释放，存放==函数的参数值，局部变量==等

注意：==不要返回局部变量的地址==，栈区开辟的数据由编译器自动释放



**堆区：**

​	有程序员非陪释放，若程序员不释放，程序结束时由操作系统回收

​	在C++中主要利用new在堆区开辟内存

```c++
// 堆区
#include <iostream>

using namespace std;

int * func()
{
    // 利用new关键字将数据开辟到堆区
    int *p = new int(10); // p仍是局部变量,放在栈区，指针保存的数据放在堆区
    return p;
}

int main(int argc, char **argv)
{
    int *p = func();
    cout << *p << endl;
    return 0;
}
```

![image-20201111175518090](pics/05_%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20201111175518090.png)

## 1.3 new操作符

堆区开辟的数据由程序员释放，利用`delete`，程序员不释放操作系统在程序结束时释放

语法：`new 数据类型`， 利用new创建的数据，会返回该数据对应类型的指针

利用`delete`释放数组时要用`delete[] 数组名;`



## 静态变量

* 静态局部变量：函数结束后，静态局部变量的内存空间不会被系统回收，下一次调用函数时使用上一次退出时的值，作用域是局部。
  * 静态局部变量如果不初始化，会被自动初始化为0或NULL，建议自行初始化
* 静态全部变量：类似与静态局部变量，静态全部变量作用域全局
  * ==静态全局变量只能在它所声明的文件中使用，不能被extern关键字引用，静态全局变量的作用域比全局变量小==
  * 全局变量可以在本文件中使用，也能在其他文件中使用，需要加extern