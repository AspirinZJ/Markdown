# 构造函数和析构函数

如果不提供构造函数和析构函数， 编译器会提供，编译器提供的是空实现

* 构造函数：主要为创建对象时为对象成员属性赋值，编译器自动调用，无需手动调用
* 析构函数：主要作用于销毁对象前系统自动调用，执行清理工作



构造函数语法：`类名(){}`

1. 构造函数，没有返回值，也不写void
2. 构造函数函数名于类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时会自动调用构造函数，无需手动调用，而且只会调用一次



析构函数语法：`~类名(){}`

1. 析构函数，没有返回值，也不写void
2. 析构函数函数名为~类名
3. 析构函数没有参数，因此不能重载
4. 程序在对象销毁前会自动调用析构函数，无需手动调用

# 构造函数的分类和调用

两种分类方式：

* 按参数分：有参构造和无参构造
* 按类型分：普通构造和拷贝构造

三种调用方式：

* 括号法
* 显式法
* 隐式转换法

# 拷贝构造函数的调用时机

1. 使用一个已经创建完毕的对象来初始化一个新对象
2. 以值传递的方式给函数传值
3. 以值方式来返回局部对象

# 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1. 默认构造函数（无参构造，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 拷贝构造函数，对属性值进行拷贝



构造函数调用规则如下：

* 如果用户定义有参构造函数，c++不提供默认的无参构造，但是会提供默认拷贝构造
* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数

# 深拷贝与浅拷贝

* 浅拷贝： 简单的赋值拷贝操作
* 深拷贝： 在堆区重新申请空间，进行拷贝操作

b

浅拷贝带来的问题是堆区到内存重复释放

浅拷贝的问题，要利用深拷贝解决。

如果成员属性中有在堆区开辟的， 一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。

```c++
#include <iostream>

using namespace std;

class Person
{
    public:
        int mAge;
        float *mHeight;
        Person() { cout << "默认构造函数" << endl;}
        Person(int age, float height) {
            cout << "有参构造函数" << endl;
            mAge = age;
            mHeight = new float(height);
        }

        // **** 自己实现拷贝构造函数，解决浅拷贝带来到问题
        Person(const Person &p)
        {
            cout << "拷贝构造函数" << endl;
            mAge = p.mAge;
            // mHeight = p.mHeight; // 编译器默认实现这行代码，浅拷贝
            mHeight = new float(*p.mHeight);    // 深拷贝
        }
        ~Person() 
        {
            // 析构代码，将堆区开辟到数据释放
            if (mHeight != NULL)    {delete mHeight; mHeight = NULL;}
            cout << "析构函数" << endl;
        }
};

void test1()
{
    Person person1(18, 160.5);
    Person person2(person1);
    // 会报错，因为person1和person2的mHeight指针指向同一内存空间
    // 当调用完person2析构函数之后，person1中析构函数delete时会报错
}

// int main(int argc, char **argv)
int main()
{
    test1();
    return 0;
}
```

# 初始化列表

初始化属性

语法：`构造函数() : 属性1（值1）， 属性2（值2）， ...{}`

# 类对象作为类成员

对象成员： 类的成员是另一个类的对象

```c++
class A{};
class B
{
	A a;
};
```

当其他类的对象作为本类成员，先构造其他类的对象，再构造自身                                                                                                             析构的顺序与构造相反

# 静态成员

静态成员就是在成员函数加static



静态成员变量：

* 所有对象共享统一分数据
* 在编译阶段分配内存的全局区
* 类内声明，类外初始化



静态成员变量不属于某个对象，因为所有对象共享同一份数据，因此静态成员变量有两种访问方式                                                                       

1. 通过对象进行访问
2. 通过类名进行访问



private静态成员属性无法类外访问

---

静态成员函数：

* 所有对象共享一个函数
* 静态成员函数只能访问静态成员变量，不可以访问非静态成员变量（因为所有对象共享静态成员函数，因为非静态成员变量属于某个对象，而静态成员函数所有对象都可以访问，通过类名也能访问）



静态成员函数访问方式：

1. 通过对象进行访问： `对象名.静态成员名`
2. 通过类名进行访问： `类名::静态成员名`， 推荐使用此方式访问，因为静态成员属于整个类而不是某个特定的对象



private静态成员函数不能在类外访问

# C++对象模型和this指针

## 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储，==只有非静态成员变量才属于类的对象上==



空对象占用的内存空间为1,C++编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置

每个空对象都有单独的内存地址

# this指针

由于C++中成员变量和成员函数分开存储，每一个非静态成函数只会生成一份函数实例，也就是说多个同类型的对象会共用一块代码，那么问题是：这一块带买是如何区分哪个对象调用自己的呢？

C++通过this指针解决以上问题，this指针指向被调用的成员函数所属的对象

this指针是隐含每一个非静态成员函数内的一种指针，this指针不需要定义，直接使用即可



this指针的用途：

* 当形参和成员变量同名时，可用this指针来区分
* 在类的非静态成员函数中返回对象本身，可使用`return *this;`



==this指针的本质是指针常量，不可以修改指针的指向==

# 空指针访问成员函数

C++中空指针也可以调用成员函数，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

# const修饰成员函数

**常函数**

* 成员函数==之后==加const成为常函数
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改
* ==值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象的值。==



**常对象**

* 声明对象前加const成为常对象
* 常对象不能修改普通的成员变量，但能修改mutable修饰的成员变量
* 常对象只能调用常函数，不能调用普通成员函数，因为普通成员函数能够修改普通成员变量