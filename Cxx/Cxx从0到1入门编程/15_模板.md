# 模板的概念

模板就是建立通用的模具，大大提高复用性

模板的特点：

* 模板不可以直接使用，它只是一个框架
* 模板的通用并不是万能的

# 函数模板

C++一种思想称为泛型编程，主要利用的技术就是模板

C++提供两种模板机制：函数模板和类模板

## 函数模板

函数模板的作用： 建立一个函数，其函数返回值类型和形参类型可以不具体指定，用一个虚拟的类型代表

语法：

```c++
template<typename T>
函数声明或定义
```

解释：

template： 声明创建模板

typename： 表明其后面的符号是一种数据类型，可以用class代替

T： 通用的数据类型，名称可以替换，如用W，通常为大写字母



两种使用函数模板的方法：

1. 自动类型推导，直接使用函数，编译器自动判断类型
2. 显式指定类型： `函数名<类型>(参数列表);`

## 函数模板注意事项

注意事项：

1. 自动类型推导，必须推导出一致的数据类型T，才能使用
2. 模板必须要确定出T的数据类型才能使用

## 普通函数和函数模板的区别

1. 普通函数调用时可以发生自动类型转换（隐式类型转换）
2. 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
3. 如果利用显式指定类型的方式，可以发生隐式类型转换



建议使用模板函数时，使用显式指定类型的方式调用

## 普通函数和函数模板的调用规则

普通函数和模板函数可以发生重载



调用规则如下：

1. 如果普通函数和模板函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板



建议：如果提供了函数模板，就不要在提供普通函数，否则容易出现二义性

# 模板的局限性

如

```c++
template<typeneme T>
void f(T a, T b)
{
 	if (a > b) {do something;}
}
```

在上述代码中，如果传入的数据类型是一个自定义的类，无法正常运行

为了解决这种问题，C++提供模板的重载，可以为这些特定的类型提供具体化的模板

利于具体化的模板，可以解决自定义类型的通用化

* 学习模板并不是为了写模板，而是为了在STL能够运用系统提供的模板

# 类模板

类模板作用：

* 建立一个通用类，类中的成员，数据类型可以不具体指定，用一个虚拟类型来代表



语法：

```c++
template<typename T> // typename可以用class代替
类
```

## 类模板与函数模板的区别

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数，新版的C++函数模板也可以有默认参数

## 类模板中成员函数创建时机

* 普通类中的成员函数一开始就创建
* 类模板中的成员函数在调用时才创建

## 类模板对象做函数参数

学习目标：类模板实例化出的对象，向函数传参的方式



一共有三种传入方式：

1. 指定传入类型   ---直接显式对象的数据类型. 最常用
2. 参数模板化       ---将对象中的参数变为模板进行传递
3. 整个类模板化   ---将这个对象类型模板化进行传递



利用typeid函数查看模板中的数据类型



## 类模板与继承

当类模板遇到继承时的注意事项：

1. 当子类继承的父类是模板类时，子类在声明的时候，要指定出父类的数据类型
2. 如果不指定，编译器无法给子类分配内存
3. 如果想灵活地指定父类中T的类型，子类也要是类模板



## 类模板成员函数的类外实现

需要在实现函数前面用template，并且实现时作用域要传入模板参数

## 类模板分文件编写

问题：

* 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

解决         ：

1. 直接包含cpp源文件，因为类模板中的成员函数只有在调用时才创建，一开始不会创建，如果只包含.h文件，导致编译时编译器不会看到类cpp中的函数实现代码，链接阶段时就无法链接。如果直接包含cpp文件，因为cpp文件中include了.h文件，也看到了cpp中的函数实现，所以可以正常调用。==比较少使用这种方式==
2. 将声明和实现写入同一个文件中，并将后缀名写为hpp，hpp是约定的名称，并不是强制

## 类模板与友元

* 类模板与友元函数的类内实现和类外实现

全局函数类内实现：直接在类内声明友元即可

全局函数类外实现：需要提前让编译器知道全局函数的存在

