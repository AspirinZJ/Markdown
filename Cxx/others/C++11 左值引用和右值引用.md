# C++11常用特性介绍——左值引用、右值引用

## 一、左值、右值

　　1）左值：可以放在赋值号左侧、==可以被赋值==的值；左值必须要在内存中有实体。　　

　　2）右值：必须放在赋值号右侧、取出值赋值给其它变量；右值==可以在内存中也可以在CPU寄存器中==。

## 二、引用

　　引用是C++语法做优化，引用的本质还是靠指针来实现的，引用相当于变量的别名。

　　声明引用的时候必须初始化，且一旦绑定，不能对引用重定义，对引用的一切操作，相当于对原对象的操作。

## 三、左值引用

　　C++11之前，没有左值引用和右值引用之分，引用专指左值引用

　　左值引用的基本语法：type & 引用名 = 左值表达式，如：

```c++
　　int a = 1;
　　int &b = a;//a必须是左值，不能为右值
　　int &c = 1;//错误，1为右值
```

　　C++11前为了使引用接受左值又能接受右值，对const &添加了特殊技能，如：

```c++
cont int& c = 1;//正确
```

　　但是这种解决方式只能解决参数不变的情况，如果参数可变问题依然存在，为了解决这种问题，C++11引入了右值引用

## 四、右值引用

　　右值引用的基本语法：`type && 引用名 = 右值表达式`，如：

```c++
int && a = 1;//1为右值(&&中间不可以有空格)
```

## 五、万能引用

　　如果一个地方即有左值引用，又有右值引用，而且功能函数内容相同，这样就要写两遍代码，问题变得更麻烦了，如：

```c++
　　#include <iostream>

　　void Func(const i &){
　　　　std::cout << i << std::endl;
　　}

　　void Func(int i&){
　　　　std::cout << i << std::endl;
　　}

　　void Func(int &&i){
　　　　std::cout << i << std::endl;
　　}

　　int main()
　　{
　　　　int a = 1;
　　　　const int b = a;
　　　　Func(b);//调用Func(const int &i);
　　　　Func(a);//调用Func(int &i);
　　　　Func(1);//调用Func(int && i);
　　}
```

　　为了解决这个问题，在模板函数上添加了一个完美转发语法，这样上面的几个函数可以合成一个函数， 如：

```c++
　　template <typename T>

　　void Func(T && t){
　　　　std::cout << t << std::endl;
　　}
```

　　注：这里的==&&==已经不是右值引用了，而是被称为==万能引用(universal references)==，而这种用法称为==完美转发==。

