# 语法

使用`::*`声明一个成员指针类型，或者定义一个成员指针变量。使用`.*`或者`->*`调用类成员函数指针所指向的函数，这时必须绑定（binding）于成员指针所属类的一个实例的地址。例如：

```c++
struct X {
  void f(int){ };
  int a;
};
void (X::* pmf)(int); //一个类成员函数指针变量pmf的定义
pmf = &X::f;            //类成员函数指针变量pmf被赋值
 
X ins, *p;
p=&ins;
(ins.*pmf)(101);       //对实例ins，调用成员函数指针变量pmf所指的函数
(p->*pmf)(102);      //对p所指的实例，调用成员函数指针变量pmf所指的函数
```

由于[C++运算符优先级列表](http://zh.wikipedia.org/wiki/C和C%2B%2B运算符)中，函数调用运算符`()`的优先级高于`.*`与`->*`，因此成员函数指针所指的函数被调用时，必须把实例对象或实例指针、`.*`或`->*`运算符、成员函数指针==用括号括起来==，如上例所示。

C++标准规定，非静态成员函数不是左值，因此非静态成员函数不存在表达式中从函数左值到指针右值的隐式转换，==非静态成员函数指针必须通过&运算符显式获得==。所以上例中，pmf = X::f; 将编译报错。

# 语义

不同于普通函数，类成员函数的调用有一个特殊的不写在形参表里的隐式参数：类实例的地址。因此，C++的类成员函数调用使用`thiscall`调用协议。类成员函数是限定(qualification)于所属类之中的。

同样，类成员函数指针与普通函数指针不是一码事。前者要用.*与->*运算符来使用，而后者可以用`*`运算符（称为“解引用”dereference，或称“间址”indirection）。普通函数指针实际上保存的是函数体的开始地址，因此也称“代码指针”，以区别于C/C++最常用的数据指针。而类成员函数指针就不仅仅是类成员函数的内存起始地址，还需要能解决因为C++的[多重继承](http://zh.wikipedia.org/wiki/多重继承)、[虚继承](http://zh.wikipedia.org/wiki/虚继承)而带来的类实例地址的调整问题。因此，普通函数指针的尺寸就是普通指针的尺寸，例如32位程序是4字节，64位程序是8字节。而类成员函数指针的尺寸最多有4种可能：

- 单倍指针尺寸：对于**非派生类**、**单继承类**，类成员函数指针保存的就是成员函数的内存起始地址。
- 双倍指针尺寸：对于**多重继承类**，类成员函数指针保存的是成员函数的内存起始地址与this指针调整值。因为对于多继承类的类成员函数指针，可能对应于该类自身的成员函数，或者最左基类的成员函数，这两种情形都不需要调整this指针。如果类成员函数指针保存的其他的*非最左*基类的成员函数的地址，根据C++标准，*非最左*基类实例的开始地址与派生类实例的开始地址肯定不同，所以需要调整this指针，使其指向*非最左*基类实例。
- 三倍指针尺寸：对于多重继承且虚继承的类。类成员函数指针保存的就是成员函数的内存起始地址、this指针调整值、虚基类调整值在虚基表（vbtable）中的位置共计3项。以常见的“菱形虚继承”为例。*最派生类*多重继承了两个类，称为左父类、右父类；两个父类共享继承了一个虚基类。*最派生类*的成员函数指针可能保存了这四个类的成员函数的内存地址。如果成员函数指针保存了*最派生类*或左父类的成员函数地址，则最为简单，不需要调整this指针值。如果如果成员函数指针保存了右父类的成员函数地址，则this指针值要加上一个偏移值，指向右父类实例的地址。如果成员函数指针保存了虚基类的成员函数地址，由于C++类继承的复杂多态性质，必须到*最派生类*虚基表的相应条目查出虚基类地址的偏移值，依此来调整this指针指向虚基类。
- 四倍指针尺寸：C++标准允许一个仅仅是声明但没有定义的类（forward declaration）的成员函数指针，可以被定义、被调用。这种情况下，实际上对该类一无所知。这称作未知类型（unknown）的成员函数指针。该类的成员函数指针需要留出4项数据位置，分别用于保存成员函数的内存起始地址、this指针调整值、虚基表到类的开始地址的偏移值（vtordisp）、虚基类调整值在虚基表（vbtable）中的位置，共计4项。

C++标准并没有明确规定类成员指针在派生类与基类之间的类型转换。但不允许类成员函数指针与其它无继承关系的类的成员函数指针互相转换。不允许与普通函数指针互相转换。

如果把基类的虚函数赋给派生类的成员函数指针，例如

```
DerivedClass_Func_to_Mem = & BaseClass::virtualFunc;
```

实际上是把基类虚表中该虚函数条目对应到了派生类成员函数指针。调用该成员函数指针会执行到哪个函数，需要动态决定。

类成员函数指针可以用0赋值；可以用==运算符、!=运算符。但不允许使用其他的指针算术与比较运算符，如>、<等等。

不能把类的静态成员函数赋值给类成员函数指针。类的静态函数只能赋值给普通函数指针。因为类的静态成员函数不具有this指针，不采用thiscall调用协议，实际上是限定于类作用域的普通函数。 所以，确切地说，应该称“类非静态成员函数指针”。

对于[g++](http://zh.wikipedia.org/wiki/G%2B%2B)编译器，不支持把虚基类的成员函数指针赋给派生类的成员函数指针。也即，g++不支持在虚继承关系下的成员函数指针的upcast。这大大简化了g++成员函数指针的实现难度。g++编译出来的成员函数指针长度都是8字节，其中的高4字节是用于多重继承时调整this指针的偏移值，单继承时该值为0；低4字节是个union结构，对于非虚成员函数就是函数体的内存起始地址，对于虚函数是该函数在虚表（vtable）中的地址字节偏移量再加上1。这是因为，函数体的内存起始地址起码是4字节边界对齐，所以该值是4的的倍数；而虚表中每个条目是4字节长度（对于32位程序），虚函数所对应的虚表条目在虚表中的按字节计算的偏移量也是4的倍数，加上1后就是个奇数。从而可以区分非虚函数与虚函数两种情形。



# 类成员函数的指针（非静态）

指向类成员函数的指针与普通函数指针的区别在于，==指向类成员函数的指针需要匹配函数的参数类型和个数以及返回值类型，还要匹配该函数指针所属的类类型==。

这是因为==非静态的成员函数必须被绑定到一个类的对象或者指针上，才能得到被调用对象的 this 指针，然后才能调用指针所指的成员函数==（所有类的对象都有自己数据成员的拷贝，但是==成员函数都是共用的，为了区分是谁调用了成员函数，就必须有 this 指针，this 指针是隐式的添加到函数参数列表里去的==）。

所以，对于类成员函数的指针使用包含以下几个步骤：

1. **声明：** ==指向类的成员函数的指针需要在指针前面加上类的类型==，格式为：

```c++
typedef 返回值 (类名::*指针类型名)(参数列表);
```

2. **赋值：** 需要用类的成员函数地址赋值，格式为：

```c++
指针类型名  指针名 = &类名::成员函数名;
```

*注意：这里的这个 & 符号是比较重要的：不加 &，编译器会认为是在这里调用成员函数，所以需要给出参数列表，否则会报错；加了 &，才认为是要获取函数指针。这是 C++ 专门做了区别对待。*

3. **调用：** 针对调用的对象是对象还是指针，分别用.* 和 ->* 进行调用，格式为：

```c++
(类对象.*指针名)(参数列表);

(类指针->*指针名)(参数列表);
```

*注意：这里的前面==一对括号==是很重要的，因为 () 的优先级高于成员操作符指针的优先级。*

直接来看一个示例吧：

```c++
class Calculation
{
public:
    int add(int a,int b){ //非静态函数
        return  a + b;
    }
};

typedef int (Calculation::*FuncCal)(int,int);

int main()
{
    FuncCal funAdd = &Calculation::add;
    Calculation * calPtr = new Calculation;
    int ret = (calPtr->*funAdd)(1,2);  //通过指针调用

    Calculation cal;
    int ret2 = (cal.*funAdd)(3,4);  //通过对象调用

    cout << "ret = " << ret << endl;
    cout << "ret2 = " << ret2 << endl;
    return 0;
}
```

# 指向类的静态函数的指针

==类的静态成员函数和普通函数的函数指针的区别在于，他们是不依赖于具体对象的，所有实例化的对象都共享同一个静态成员，所以静态成员也没有 this 指针的概念==。

所以，==指向类的静态成员的指针就是普通的指针==。

```c++
class Calculation
{
public:
    static int add(int a,int b){ //非静态函数
        return  a + b;
    }
};

typedef int (*FuncCal)(int,int);

int main()
{
    FuncCal funAdd = &Calculation::add;
    int ret = (*funAdd)(1,2);  //直接引用
    int ret2 = funAdd(3,4);  //直接引用

    cout << "ret = " << ret << endl;
    cout << "ret2 = " << ret2 << endl;
    return 0;
}
```

总结以上两种情况的区别：

- 如果是类的静态成员函数，那么使用函数指针和普通函数指针没区别，使用方法一样
- 如果是类的非静态成员函数，那么使用函数指针需要加一个类限制一下。

使用函数指针，很多情况下是用在函数的参数中，在一些复杂的计算，如果需要重复调用，并且每次调用的函数不一样，那么这时候使用函数指针就很方便了，可以减少代码量。