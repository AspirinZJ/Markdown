# 一个对象的内存图

![image-20210206221754677](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210206221754677.png)

# 两个对象内存图

![image-20210206222443637](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210206222443637.png)

# 两个引用指向同一个对象内存图

![image-20210206223341013](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210206223341013.png)

C++中的拷贝构造函数：

* 定义一个对象时，以本类另一个对象作为初始值，发生复制构造；（Java中是将已有对象的地址传给新的对象）
* 如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；（Java中是将实参对象的地址传给形参)
* 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。（Java中，函数返回的是函数内创建的对象的地址）

# 使用类作为方法参数

使用类作为方法的参数时传递的是对象的地址值，与c++不同，c++会调用拷贝构造函数

![image-20210206224409254](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210206224409254.png)

# 类作为方法返回值

![image-20210207014707351](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210207014707351.png)

# 成员变量和局部变量的区别

1. 定义的位置不同： 局部变量在方法内部，成员变量在方法外部，直接写在类内
2. 作用域不同： 局部变量只有方法中可以使用，成员变量整个类可以使用
3. 默认值不同：局部变量没有默认值，使用必须手动赋值，成员变量有默认值，默认值规则和数组相同
4. 内存位置不同：局部变量在栈内存，成员变量在堆内存
5. 声明周期不同：局部变量随着方法压栈诞生随着方法弹栈消失，成员变量随着对象创建而诞生随着对象被垃圾回收消失



当方法的局部变量和成员变量相同时，根据就近原则，优先使用局部变量，如果需要访问本类中的成员变量，需要用`this.成员变量`



# 面向对象三大特性之封装

* Setter: `命名规则： setXxx小驼峰命名， void返回类型，参数与set的变量参数相同`
* Getter: `命名规则： getXxx小驼峰命名，无参数列表，返回值类型与get变量相同`
* 注意：`对于基本类型中的boolean类型，Setter命名方式与以上相同，Getter命名要isXxx命名`

# 构造方法

格式：`public 类名称(参数列表) {方法体}`

注意：

1. 构造方法名称和类名完全相同
2. 构造方法没有返回类型， 连void也没有
3. 如果没有编写任何构造方法，那么编译器将会默认提供一个构造方法， 没有参数，方法体什么事情都不做
4. 一旦编写了至少一个构造方法，那么编译器将不再提供构造方法
5. 构造方法可以重载

# 标准的类

一个标准的类通常满足：

1. 所有的成员变量都要使用private修饰
2. 为每一个成员变量编写Getter/Setter
3. 编写一个无参数构造方法
4. 编写一个全参数的构造方法

这样标准的类也叫Java Bean

IntellijIdea中可以通过code->generator下面自动生成构造函数和Getter/Setter

# API概述和使用步骤

API(应用程序编程接口， JDK提供的接口， Java API是一本程序员使用的字典)使用步骤：

1. 看包。java.lang下的类不需要导包，其他需要
2. 看类的解释和说明
3. 学习构造方法
4. 使用成员方法



# Scanner概述

引用类型的一般使用步骤：

1. 导包: import 包路径.类名称，如果处于同一个包，可以省略导入语句, 只有java.lang包下的内容不需要导包
2. 创建: 类名称 对象名 = new 类名称();
3. 使用



Scanner在 java.util包下，使用需要`import java.util.Scanner`



# 匿名对象

如果确定有的对象只使用一次，可以创建匿名对象



# Random

Random在java.util包中， `import java.util.Random`

获取一个随机int:

*  `Random.nextInt() -> 范围是int所有的范围（正负都有）`
* `Random.nextInt(int range) -> 获取一个随机int，range代表类范围，左闭右开区间，如Random.nextInt(10) 代表了[0, 10)`



# 对象数组

数组有一个缺点，一旦创建，运行期间长度不可以改变



# ArrayList集合类

`java.util.ArrayList`是大小可变的数组的实现，，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素，可以不断添加元素，其大小也自动增长。



使用步骤：

* 查看类

  * `java.util.ArrayList <E>`, `<E>`表示一种数据类型，叫做泛型，取自`Element`首字母， 如`ArrayList<String>, ArrayList<Person>`

  * 注意，==泛型只能是引用类型， 不能是基本类型==， ==如果希望向ArrayList中添加基本数据类型，必须使用基本类型对应的“包装类”==。 

    * | 基本类型 | 包装类(引用类型， 包装类都位于java.lang下) |
      | -------- | ------------------------------------------ |
      | byte     | Byte                                       |
      | short    | Short                                      |
      | int      | ==Integer==                                |
      | long     | Long                                       |
      | float    | Float                                      |
      | double   | Double                                     |
      | char     | ==Character==                              |
      | boolean  | Boolean                                    |

  * 从JDK1.5+，支持自动装箱和自动拆箱了

    * 自动装箱： 基本类型-->包装类型
    * 自动拆箱：包装类型-->基本类型

* 构造方法

  * `public ArrayList()` 构造一个内容为空的集合
  * 基本格式：`ArrayList<String> list = new ArrayList<String>();`, 简化格式：`ArrayList<String> list = new ArrayList<>();`

* 常用方法：

  * `public boolean add(E e)`向集合中添加元素，参数类型和泛型一致
  * `public E get(int index)`:从集合中获取index对应位置的元素，编号从0开始
  * `public E remove(int index)`: 从集合中删除index对应位置的元素，返回值就是被删除掉的元素
  * `public int size()`: 获取长度u

* 注意：

  * 对于ArrayList， 直接打印得到的不是地址值，是内容
  * 对于ArrayList来说，add动作一定成功，返回值可用可不用，对于其他集合，add动作不一定成功



# String类

Java程序中所有的字符串字面值如"abc"都作为String类的实例实现

* 程序中所有“”包括的字符串都是String类的对象，就算没有new，也是

* 字符串是常量， 值在创建后不可以更改
* 正是因为字符串不可改变，所以字符串是可以共享使用的
* 字符串效果上相当于是char[] 型字符数组，但是底层上是byte[] 字节数组



String的3种常用构造方法+1种直接创建：

* `public String()`，创建一个空白字符串，不含有任何内容
* `public String(char[] array)`， 根据字符数组内容创建字符串
* `public String(byte[] array)`，根据字节数组的内容创建字符串
* `String str = "字符串"`直接用双引号创建

## 字符串的常量池

程序当中==直接写==上的双引号字符串，就在字符串常量池中， ==new出的不在字符串常量池==

* 对于基本类型来说， `==`是进行值的比较
* 对于引用类型来说，`==`是进行地址的比较



堆内存当中有一块空间，叫字符串常量池

![image-20210207183916062](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210207183916062.png)

## 字符串比较方法

== 比较的是字符串的地址，字符串内容比较有两种常用方法：

* `public boolean equals(Object obj)`， 参数可以是任何对象， 只有参数是一个字符串并且内容相同才返回true
  * 任何对象都能用Object进行接收
  * `equals`方法具有对称性，也就是a.equals(b)和b.equals(a)效果相同
  * 如果比较双方一个常量一个变量，推荐把常量字符串写在前面， 推荐`"abc".euqals(str)`， 不推荐`str.equals("abc")`
* `public boolean equalsIgnoreCase(String str)`： 忽略大小写进行字符串比较

## 字符串与获取相关的方法

* `public int length()`： 获取字符串的长度
* `public String concat(String str)`： 将当前字符串和参数字符串拼接成为==新的==字符串返回，用+也可以， 记住==字符串是常量， 要改变的化必定创建了新字符串==
* `public char charAt(int index)`：获取指定索引位置的单个字符
* `public int indexOf(String str)`： 查找参数字符串在本字符串中首次出现的索引位置，没有返回-1

## 字符串截取相关方法

字符串截取方法：

* `public String substring(int index)`：从index位置开始截取到字符串末尾，返回==新字==符串
* `public String substring(int begin, int end)`： 截取从`[begin, end)`区间的字符串，返回新的字符串，左闭右开

## 字符串转换相关方法

字符串转换方法：

* `public char[] toCharArray()`： 将当前字符串拆分成字符数组返回
* `public byte[] getBytes()`： 获得当前字符串底层的字节数据
* `public String replace(CharSequence oldString, CharSequence newString)`： 将所有出现的老字符串替换为新字符串，返回替换之后的结果为新的字符串， `CharSequence`意思就是可以接收字符串类型 

## 字符串分割方法

`public String[] split(String regex)`：按照==正则表达式==参数的规则，将字符串切分成若干部分

* split方法的参数是正则表达式, `.`必须用`\\.`表示



# 静态static关键字

![image-20210208013552163](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210208013552163.png)

* 如果一个成员变量使用了static关键字，那么这个变量不再属于自己，而是属于所在的类，多个对象共享一份数据
* 如果一个成员方法使用类static关键字， 那么这就成了静态方法，静态方法不属于对象， 而属于类
  * 如果没有static关键字，那么要先创建对象，再通过对象使用
  * static修饰的静态方法，可以通过对象调用，也可以通过类名直接调用（不需要创建对象再调用）
* 静态变量和静态方法推荐使用`类名称.静态方法名/静态变量名`调用
* 对于本类当中的静态方法，可以省略类名称
* ==静态不能访问非静态==，因为在内存当中先有的静态内容，后有的非静态内容，先不知道后，后知道先，也可以理解为所有对象共享同一份静态方法，也可以通过类名调用静态方法，如果能访问非静态就乱了。。
* 静态方法中不能用this， 因为this代表当前对象

![image-20210208022015008](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210208022015008.png)

# 静态代码块

特点：当第一次用到本类时，静态代码块执行唯一的一次

静态内容总是优先与非静态，所以静态代码块比构造方法先运行

静态代码块的典型用途是一次性地对静态成员变量进行赋值

格式：

```java
public class 类名称
{
	static
	{
	静态代码块的内容
	}
}
```



# 数组工具类Arrrays

java.util.Arrays是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组常见的操作

* `public static String toString(数组)`：减参数数组变成字符串，按照默认格式：[元素1, 元素2, ...]
* `public static void sort(数组)`： 按照默认升序堆数组的元素进行排序
  * 如果是数值，sort按照升序排序
  * 如果是字符串，sort按照字母升序
  * 如果是自定义类型，那么这个自定义类需要有Comparable或者Comparator接口的支持



# 数学工具类Math

`java.util.Math`是数学相关的工具类，提供了大量的静态方法

* `public static double abs(double num)`： 获取绝对值
* `public static double ceil(double num)`：向上取整
* `public static double floor(double num)`： 向下取整
* `public static long round(double num)`： 四舍五入
* `Math.PI`：近似圆周率常量

==java 中double可以++==

# 继承

关系： 子类和父类： 子类就是父类， is-a， 如老师就是员工

格式：

```java
public class 父类{}

public class 子类 extends 父类 {}
```



继承中成员变量访问特点:

* 在继承关系中，如果成员变量重名
  * 直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找
  * 间接通过成员方法访问成员变量：该方法属于谁，就优先用谁，没有则向上找



区分子类方法中重名的三种变量（父类、子类、局部）：

* 局部变量：直接写
* 子类成员变量：this.成员变量
* 父类成员变量：super.成员变量

# 继承中成员方法的访问特点

在父子类继承关系中，创建子类对象访问成员方法的规则：

* 创建的对象是谁，就优先用谁，没有再向上找
* 注意：
  * 无论成员方法还是成员变量，如果没有都向上找，绝对不会向下找子类的



# 继承中方法的重写

重写override：在继承关系中，方法的名称一样，参数列表也一样，如果创建的是子类的对象，则优先使用子类的方法

==`@Override`:写在方法前面，用来检测是不是有效的正确重写==， `@`是annotation， 注解

注意：

* 必须保证父子类方法名称相同，参数列表也相同
* `@Override`就算不写，只要满足要求，也是正确的重写， 它只是一种安全检测, ==推荐写==
* ==子类方法的返回值必须小于等于父类方法的返回值范围==， 例如，String有一个父类Object， java.lang.Object类是所有类的公共最高父类，如果父类返回Object，子类可以返回String
* ==子类方法的权限修饰符必须大于等于父类方法的权限修饰符==， ==从大到小是`public > pretected > (default) > private`==
  * 注意(default)不是关键字，而是什么都不写，留空



重载和重写的区别

* 重写override：方法的名称一样，参数列表也一样。也叫方法的覆盖/覆写。
* 重载overload：方法的名称一样，参数列表不一样

# 继承中构造方法的访问特点

继承中，父子类构造方法的访问特点：

* 子类的构造方法之中有默认隐含的`super()调用`， 什么都没写，则默认存在，所以一定先调用父类构造再调用子类构造， 此时如果父类没有无参构造函数，不写会报错
* 可以通过`super`关键字，来子类构造调用父类重载构造
* super的父类构造调用必须是子类构造方法的第一个语句
* 子类构造方法中不能调用多个父类构造方法
* 子类必须调用父类构造方法，不写则赠送父类默认构造方法，写了则用写的指定的父类的构造方法

# super关键字的用法

super关键字的用法：

* 在子类的成员方法中，访问父类的成员变量
* 在子类成员方法中，访问父类的成员方法
* 在子类构造方法中，访问父类的构造方法

# this关键字用法

this关键字三种用法：

* 在本类成员方法中，访问本类的成员变量
* 在本类的成员方法中，访问本类的另一个成员方法
* 在本类的构造方法中，访问本类的另一个构造方法
  * 注意，this()调用也必须是构造方法中的第一个语句
  * 注意，super()调用和this()调用不能同时使用，因为他们两个必须是第一个语句

# super 和this 内存图

![image-20210209005957664](pics/002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20210209005957664.png)

# Java继承的三个特点

Java继承的三个特点：

* Java是单继承：一个类的父类只能有唯一一个

  * ```java
    class A{}
    class B extends A{} // 正确
    class C {}
    class D extendsA, C {}// 错误
    ```

* Java语言可以多级继承， `java.lang.Object`是继承顶端的类

* 一个子类直接父类唯一，一个父类可以拥有多个子类

# 抽象

抽象方法格式：`abstrac 方法名();`前面加上abstract，后面去掉大括号，直接分号结束

抽象类：抽象方法所在的类，在class之前加上abstract



抽象类和抽象方法使用步骤：

* 不能直接创建new抽象类对象
* 必须使用一个子类继承抽象类
* 子类必须覆盖重写（实现）抽象父类中所有的抽象方法， 去掉abstract关键字，然后补上方法体，否则子类也是抽象类



抽象类和抽象方法注意事项：

* 抽象类无法创建对象
* 抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的
* 抽象类不一定需要有抽象方法， 没有抽象方法的抽象类也不能直接创建对象
* 抽象类的子类必须重写所有抽象方法，否则，子类也是抽象类



# 接口

接口就是一种公共的规范标准， 只要符合标准就可以大家通用

==接口是一种引用数据类型==， 接口中最重要的内容，就是其中的抽象方法

定义接口格式：

```java
public interface 接口名称
{
...
}
```

备注：

* `无论对于类还是对于接口，生成的字节码文件.java-->.class`
* 如果是Java7,接口中可以包含：
  * 常量
  * 抽象方法
* 如果是Java8,还可以额外包含有：
  * 默认方法
  * 静态方法
* 如果是Java9,还可以额外包含：
  * 私有方法



定义接口抽象方法：`public abstract 返回值类型 方法名称(参数列表);`



接口使用步骤：

* 接口不能直接使用，必须有一个“实现类”来“实现”该接口， ==实现类命名推荐`接口名Impl， 如MyInterfaceImpl`==
  * 格式：`public class 实现类名称 implements 接口名称 {..}`
* 接口的实现类必须重写(实现)接口中所有的抽象方法
* 创建实现类的对象进行使用



注意事项：

* 接口中的抽象方法，修饰符必须是两个固定的关键字: public abstract，这两个关键字可以选择性省略
* 如果实现类没有重写全部的抽象方法，那么这个实现类就必须是抽象类

## 接口默认方法

从Java8开始，允许接口定义默认方法，默认方法可以有方法体， 格式：

```java
public default 返回值类型 方法名称(参数列表) 
{方法体}
```

接口中的默认方法，可以解决接口升级的问题，如果接口升级，如新添加了一个抽象方法，那么之前接口所有的实现类都要改动重写新的抽象方法，不便于维护，所以可以为接口提供带有方法体的默认方法

默认方法会被实现类继承



注意：

* 接口的默认方法可以通过接口实现类对象直接调用
* 接口的默认方法也可以被接口实现类进行重写



看到了P177